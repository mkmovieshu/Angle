# app/ads/service.py
import os
import logging
import uuid
import httpx
from datetime import datetime
from urllib.parse import urlencode

from app.database import ad_sessions
from app.config import SHORTX_API_KEY, DOMAIN

log = logging.getLogger("ads.service")


async def create_ad_session(user_id: int):
    """
    Create an ad session for the user.
    Returns (token, short_url).
    The short_url is generated by provider if API key present, and we include
    a return param pointing back to our server so provider redirects back to:
        https://{DOMAIN}/ad/complete/{token}
    Provider must respect the 'url' param (most shorteners do).
    If provider not usable, fallback to our internal landing URL which can
    redirect or show instructions.
    """
    token = uuid.uuid4().hex
    short_url = None

    # Our own return url for verification (provider should redirect to this after ad)
    return_url = f"https://{DOMAIN}/ad/complete/{token}"

    # Try provider if API key present
    if SHORTX_API_KEY:
        try:
            # Example provider call (shortxlinks style)
            # We set destination to provider's ad target or some landing that triggers ad experience.
            # Many providers will accept 'url' param and produce a short link that ultimately logs clicks
            dest = return_url  # we want provider to redirect back to our return_url after ad flow
            api_endpoint = "https://shortxlinks.com/api"
            params = {"api": SHORTX_API_KEY, "url": dest}
            async with httpx.AsyncClient(timeout=10.0) as client:
                r = await client.get(api_endpoint, params=params)
                if r.status_code == 200:
                    data = r.json()
                    if isinstance(data, dict) and data.get("status") in ("success", "ok") and data.get("shortenedUrl"):
                        short_url = data.get("shortenedUrl")
                    else:
                        log.warning("Shortx responded but no usable short_url: %s", data)
                else:
                    log.warning("Shortx HTTP %s: %s", r.status_code, r.text)
        except Exception as e:
            log.exception("Shortx call failed: %s", e)

    # fallback short_url if provider not used or failed
    if not short_url:
        # internal landing page which instructs user and optionally redirects to ad-provider
        short_url = f"https://{DOMAIN}/ad/landing/{token}"

    doc = {
        "token": token,
        "user_id": user_id,
        "short_url": short_url,
        "completed": False,
        "created_at": datetime.utcnow().isoformat(),
    }
    await ad_sessions.insert_one(doc)
    log.info("Ad session created token=%s user=%s short=%s", token, user_id, short_url)
    return token, short_url


async def mark_ad_completed(token: str, user_id: int) -> bool:
    """
    Mark ad session completed if exists and belongs to user.
    Returns True if changed from False->True.
    """
    rec = await ad_sessions.find_one({"token": token})
    if not rec:
        return False
    # If token exists but user mismatch, still allow marking â€” alternative: require same user
    if rec.get("completed"):
        return False
    await ad_sessions.update_one({"token": token}, {"$set": {"completed": True, "completed_at": datetime.utcnow().isoformat(), "completed_by": user_id}})
    log.info("Ad session completed token=%s user=%s", token, user_id)
    return True
